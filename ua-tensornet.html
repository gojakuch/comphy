<html lang="ua">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComPhy: Computational Physics Library</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
    <link href="style.css" rel="stylesheet" type="text/css" media="all">
    <link rel="icon" href="favicon.ico">
  </head>
  <body>
    <a href="index.html"><img alt="ComPhy" src="comphy.png" style="width:200px;height:100px"></a>
    <div class="main">
      <h1>Тензори та Тензорні Мережі</h1>
      <h2>Вступ</h2>
      <p>
        Тензорні мережі використовуються в сучасній квантовій фізиці для опису хвильових функцій, але методи прикладної математики для роботи з ними вже знайшли застосування в машинному навчанні. Квантові алгоритми для квантових комп'ютерів теж можна описувати тензорними мережами (власне кажучи, стандартні квантові схеми якоюсь мірою і є діяграми для тензорних мереж). Водночас, українською про тензорні мережі (або тензорні діяграми) майже нічого доступного не написано. Поспішаю це виправити.
      </p>
      <p>
        Для сприйняття цієї теми читач має розуміти принаймні початкову лінійну алгебру та знати, що таке теорія графів (ідеально також розуміти якісь алгоритми на графах). Зауважу також, що в цій статті для нас "тензорні мережі" та "тензорні діяграми" – синонімічні поняття. Втім, багато (можливо навіть більшість) авторів розрізняє ці поняття, вживаючи другий термін лише для графічних позначень тензорних мереж.
      </p>
      <h2>Що Таке Тензор?</h2>
      <p>
        Почнемо з простого.
      </p>
      <p>
        <b>Тензор порядку <i>n</i></b> – це математичний об'єкт, що складається з чисел (будь-якого виду), кожне з яких має <i>n</i> впорядкованих індексів і зветься <b>елементом</b> тензору. Перекладаючи простою мовою, це числовий масив виміру <i>n</i>.
      </p>
      <p>
        (Варто зазначити, що це означення підходить нам більше з точки зору комп'ютерних наук та реалізації, фізики ж означають тензори іншим чином)
      </p>
      <p>
        Прикладами тензорів суть матриці (тензори другого порядку) та вектори (першого порядку). Тензори, в цілому, варто розглядати як узагальнення векторів і матрицю на довільний розмір. Скаляри теж іноді вважаються тензорами нульового порядку.
      </p>
      <img style="display:block;margin:auto" src="img/ua-tensornet/0.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 0</i> </div>
      <div style="text-align:center"> (<a href="https://medium.com/codex/tensor-basics-in-pytorch-252a34288f2" target="_blank">image/малюнок: medium.com</a>) </div>
      <h2>Згортка Тензорів та Нотація Ейнштейна</h2>
      <p>
        <b>Згортка тензорів</b> (з англ. tensor contraction, не плутати з convolution - згортка) – це операція суми всіх елементів двох тензорів за спільним інексом, результатом якої є інший тензор. <br> Це те що я буду далі називати згорткою. Часто це ще називають <b>binary tensor contraction</b>, аби відрізняти від <b>tensor contraction</b>, яким тоді вважають просто узагальнення сліду матриці (тобто операція над одним тензором, а не над двома), але це призводить до плутанини, як на мене.
      </p>
      <p>
        Насправді, згортка тензорів в окремих випадках відома всім першокурсникам. Множення вектора на матрицю й навіть множення двох матриць - це теж згортки: \[1) b_j = \sum_i{A_{ij}v_i} \iff b = Av = \sum_i{A_iv_i}\] \[2) C_{jk} = \sum_i{A_{ji}B_{ik}} \iff С = AB = \sum_i{A_iB_i}\]
        В обох прикладах згортка відбувається за \(i\), ліворуч повний варіант, праворуч - простіший. Додамо тепер і складніший приклад для тензора \(D\) виміру 3 і матриці \(A\) \[3) T^j = \sum_i{\sum_k{{D^j}_{ik}А_{ki}}} = \sum_{i,k}{{D^j}_{ik}А_{ki}}\]
      </p>
      <p>
        Зверніть увагу, що у виразі \({D^j}_{ik}\) позначка \(j\) - це просто верхній індекс, а не степінь. Таке позначення зустрічається нерідко.
      </p>
      <p>
        Тензорна згортка це дуже часта операція, тому її запис прийнято скорочувати, але при цьому хотілося б зберігати в записі згадку про індекс, за яким ми згортаємо. Для цього існує <b>запис Ейнштейна</b> або <b>нотація Ейнштейна</b>, запишемо ним наші приклади \[1) b_j = A_{ij}v_i\] \[2) C_{jk} = A_{ji}B_{ik}\] \[3) T^j = {D^j}_{ik}А_{ki}\]
        Індекси, що зустрічаються по одному разу в кожній частині рівняння (наприклад \(j\)) називаються <b>вільними</b>, а ті, що зустрічаються двічі в одній частині рівняння - <b>зв'язними</b> або <b>зв'язанними</b>. Інших індексів не може існувати. Якщо це не зрозуміло, то далі пояснюється, чому.
      </p>
      <h2>Мережеве Представлення та Застосування</h2>
      <img style="display:block;margin:auto" src="img/ua-tensornet/1.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 1</i> </div>
      <div style="text-align:center"> (<a href="https://www.tensors.net/intro" target="_blank">image/малюнок: tensors.net</a>) </div>
      <p>
        Графічно було б зручно (з точки зору згортки) уявляти тензори як певні "вузли/фіґури з ніжками" (мал. 1), де кожен індекс - це певна ніжка. Такі позначення тензорів можна об'єднувати в <b>мережеві діяграми</b>. Ніжки, що стирчать з усієї мережі позначають вільні індекси, ніжки, що сполучають два тензори - зв'язні. Іншого виду ніжок ви намалювати не зможете, отже й інших індексів існувати не може. Тобто:
      </p>
      <p>
        <b>Тензорна мережева діяграма</b>, просто <b>тензорна діяграма</b> або <b>діяграма Пенроуза</b> (з англ. tensor diagram notation) – це спосіб графічного представлення виразів тензорної згортки та мультилінійних функцій за допомогою відображення один-до-одного на певний граф, де вершини позначають тензори, а ребра - індекси, за якими відбувається згортка.
      </p>
      <p>
        Тоді наші приклади 1), 2), 3) можна подати графічно в наступному вигляді:
      </p>
      <img style="display:block;margin:auto;width:230px;height:352px;" src="img/ua-tensornet/2.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 2</i> </div>
      <p>
        На цьому малюнку ми можемо бачити три різні тензорні мережі (надалі вживатимемо словосполучення "тензорна мережа" у графічному розумінні). Згортка в мережі відбувається об'єднанням (певним злиттям) тензорів, що зв'язані між собою індексами. В результаті згортки отримаємо новий тензор, який матиме вільні індекси за свої. Це вже дуже красиво, однак найкраще ще попереду.
      </p>
      <p>
        Хоча таке позначення й допомагає орієнтуватися при роботі з багатовимірними тензорами, було б дивно приділяти йому стільки уваги лише через це. Насправді ж, основний сенс тензорних мереж це інше, до чого можна прийти міркуючи про вирази з тензорами в такому вигляді, а саме - обернена до згортки операція - розклад тензорів. Мета розбиття тензора на частини (різними способами) може бути різна, однак більшість прикладних задач тензорних мереж зводиться до апроксимації (наближення) розбиття одного тензору у мережу.
      </p>
      <p>
        Що це дає? Менше параметрів у системі, а отже економія на операціях та пам'яті. Для прикладу, якщо наша система описується тензором порядку \(n\), то її можна наблизити за допомогою тензорної мережі з декількох тензорів, що буде згортатись до тензору порядку \(n\), але матиме менше параметрів.
      </p>
      <img style="display:block;margin:auto" src="img/ua-tensornet/3.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 3</i> </div>
      <div style="text-align:center"> (<a href="https://www.tensors.net/intro" target="_blank">image/малюнок: tensors.net</a>) </div>
      <p>
        Які системи описуються тензорами \(n\)-того порядку? Як правило, складні квантові системи, ми також можемо записати в такому вигляді цілі моделі машинного навчання, інші фізичні системи тощо. Наприклад, таким чином:
      </p>
      <img style="display:block;margin:auto" src="img/ua-tensornet/4.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 4</i> </div>
      <div style="text-align:center"> (<a href="https://www.tensors.net/intro" target="_blank">image/малюнок: tensors.net</a>) </div>
      <p>
        Тут \(|ψ⟩\) позначає систему з \(N\) підсистем (для кожної відповідний індекс \(i\)), тензор \(C\) - це по суті великий масив з коєфіцієнтами для лінійної комбінації можливих станів системи.
      </p>
      <h2>Спряжені Тензори та Інші Позначення</h2>
      <img style="display:block;margin:auto" src="img/ua-tensornet/5.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 5</i> </div>
      <div style="text-align:center"> (<a href="https://www.tensors.net/tutorial-2" target="_blank">image/малюнок: tensors.net</a>) </div>
      <p>
        На малюнку 5 наведено приклади інших позначень: діягональних матриць та їх узагальнень на тензори, унітарних матриць та їх узагальнень на тензори, обернених до них. Останні позначаються трапеціями з лінією, яка позначає вісь, відносно якої тензор є "умовно унітарним", перевенуті відносно цієї вісі трапеції позначають обернені тензори. Важливим трюком, на якому ґрунтується багато тензорно-мережевих алгоритмів є розбиття звичайних зв'язків на пару спряжених унітарних матриць, або навіть тензорів будь-якої форми, які потім можна частково чи повністю згорнути з сусідніми, що дозволяє змінювати форму мережі майже будь-яким чином (Малюнок 6).
      </p>
      <img style="display:block;margin:auto" src="img/ua-tensornet/6.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 6</i> </div>
      <h2>Центри, Алгоритми, Теореми...</h2>
      <p>
        Звісно, це лише основи теорії тензорних мереж. Як уже було сказано, до неї входять і алгоритми, і теореми й ще багато чого. Розбивати один тензор на мережу можна великою кількістю різних структур, які можуть застосовуватись у тих чи інших умовах. На жаль, наразі це єдиний матеріял про тензорні мережі українською мовою, тому за подальшим раджу звертатись до <a href="tensornet.html">англомовних джерел</a>. <br> Розглянемо, для прикладу на останок, один алгоритм. Та спершу визначимо, що таке центр ортогональности.
      </p>
      <p>
        <b>Центр ортогональности</b> (з англ. Centre of Orthogonality) у древовидних тензорних мережах – це один із тензорів мережі, що, прийнятий за корінь умовного дерева, має ізометрію на всіх гілках. Простіше кажучи, у тензорній мережі, що є деревом з точки зору теорії графів, це тензор (а тобто вершина) цієї мережі такий, що всі гілки від цього тензора можна назвати "унітарними" (див. малюнок 7).
      </p>
      <img style="display:block;margin:auto;width:40%;height:auto" src="img/ua-tensornet/7.png" alt="examples of graphic representation">
      <div style="text-align:center"> <i>Малюнок 7: центром тут буде тензор A, якщо виконуються умови праворуч</i> </div>
      <p>
        Центр ортогональности є об'єктом з декими часто бажаними властивостями, що робить його пошук потрібною практичною задачею. Власне, на один з алгоритмів його пошуку далі й подивимось.
      </p>
      <p>
        <b>Алгоритм протягування (протягу)</b> (з англ. Pulling Through) використовується для пошуку центру в древовидних тензорних мережах. Точніше, ми обираємо будь-який зручний за позицією чи розмірами тензор і, за допомогою змін, як на малюнку 6 чи просто розкладів тензорів, перероблюємо його на центр. Для цього алгоритму знадобиться поняття <a href="https://uk.wikipedia.org/wiki/QR-%D1%80%D0%BE%D0%B7%D0%BA%D0%BB%D0%B0%D0%B4_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D1%96" target="_blank">QR-розкладу</a> тензорів чи матриць на множники. Кроки:
      </p>
      <div class="row">
        <div class="column" style="padding-left:0">
          <p>
            <ol style="font-size:120%">
              <li>Орієнтуємо "ребра" в сторону обраного центру (А).</li>
              <li>Починаючи з "джерел" гілок розкладаємо тензори QR-розкладом (відносно вісі між відходячими та входячими ребрами).</li>
              <li>Перепозначити тензор за його Q частиною, а R частину згорнути до наступного тензора.</li>
              <li>Повторити для наступних тензорів.</li>
            </ol>
          </p>
        </div>
        <div class="column" style="padding-right:0">
          <img style="display:block;margin:auto;height:auto" src="img/ua-tensornet/8.png" alt="examples of graphic representation">
          <div style="text-align:center"> <i>Малюнок 8</i> </div>
          <div style="text-align:center"> (<a href="https://www.tensors.net/tutorial-3" target="_blank">image/малюнок: tensors.net</a>) </div>
        </div>
      </div>
      <p>
        Загальний сенс алгоритму, насправді, не складно осягнути. У QR-розкладі Q-частина для дійсних матриць є ортогональною, для комплексних тензорів - аналогічно. Тому, залишаючи в мережі лише такі Q-частини тензорів, ми робимо А, куди ми просто "злили" все зайве, центром.
      </p>
        <img style="display:block;margin:auto;height:auto" src="img/ua-tensornet/9.png" alt="examples of graphic representation">
        <div style="text-align:center"> <i>Малюнок 9: загальна інтуїція до алгоритму</i> </div>
        <div style="text-align:center"> (<a href="https://www.tensors.net/tutorial-3" target="_blank">image/малюнок: tensors.net</a>) </div>
    </div>

    <div style="text-align:center;padding-top:2%;"> <!-- license and credits -->
      <a href="https://atell.neocities.org">website by Atell Krasnopolski</a><br>
      <!--<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.uk" target="_blank"><img alt="Creative Commons Licence" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png"></a>-->
    </div>
  </body>
</html>
