<html lang="ua">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComPhy: Computational Physics Library</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
    <link href="style.css" rel="stylesheet" type="text/css" media="all">
    <link rel="icon" href="favicon.ico">
  </head>
  <body>
    <a href="index.html"><img alt="ComPhy" src="comphy.png" style="width:200px;height:100px"></a>
    <div class="main">
      <h1>Мова Програмування Julia</h1><div style="text-align:center">[стаття для тих, хто вже має трохи досвіду]</div>
      <p>
        Julia – це динамічна мова програмування загального призначення з убудованою підтримкою паралельних та наукових обчислень. Синтаксично не складніше за Python, за швидкістю як C, ідейно логічна. Її перевага, окрім швидкості, в тому, що код на Julia виглядає математично, а писати нею просто приємно. Ідеальна мова для обчислювальних експериментів, тому їй і варто приділити увагу. До того ж, вона вміє дуже просто взаємодіяти з Python, C та Fortran.
      </p>
      <h2 id="intro">Перші кроки</h2>
      <p>
        Найпростіший варіянт установити Julia – це завантажити редактор <a href="https://atom.io/">Atom</a> (під будь-яку ОС) та додаток Juno до нього*. Власне, сам редактор завантажується елементарно з сайту, а процес установлення Juno маю на меті показати. Альтернативно, ви можете <a href="https://julialang.org/">завантажити Julia з офіційного сайту</a> і користуватися іншими редакторами коду замість Atom. У цілому, встановити Julia перед встановленням Juno – теж непогана ідея.
      </p>
      <p><i>* – На жаль, було повідомлено про скасування подальших оновлень таких інструментів як Atom і Juno, але це все ще гарний спосіб установити мову Julia й працювати з нею. Я оновлю цю сторінку, коли буде альтернатива, або коли сформуються оновлювані копії цих програм від користувачів.</i></p>
      <p>
        У середовищі редактора Atom натискаємо Ctrl+, (контроль+кома), далі у відритій вкладці налаштувань:
      </p>
      <img style="display:block;margin:auto;width:60%;height:auto" src="img/ua-julia/1.png" alt="screenshot">
      <p>
        Далі в рядку пошуку друкуємо "Juno" й завантажуємо "uber-juno":
      </p>
      <img style="display:block;margin:auto;width:60%;height:auto" src="img/ua-julia/2.png" alt="screenshot">
      <p>
        Чекаємо, поки все завантажиться й перезапускаємо Atom. Інтерфейс редактору має трохи змінитись (див. скріншот нижче)
      </p>
      <img style="display:block;margin:auto;width:60%;height:auto" src="img/ua-julia/3.png" alt="screenshot">
      <p>
        1) REPL – інтерактивний консольний режим. Можна вводити невеличкі фрагменти коду по одному, вони будуть запускатись і обчислюватись тут. Фактично, використовувати можна як науковий калькулятор. <br>
        2) Каталог проєктів, відкриває папки та допомагає орієнтуватися, лівіше знаходиться додаткова панель інструментів. <br>
        3) Основне поле, де редагуються файли. При першому запуску тут може бути відкрити окрема вкладка з демонстраційною сторінкою, можете поставити ґалочку, аби вона не відкривалася надалі. <br>
        4) Додаткові вкладки (Workspace, Documentation, Plots), їх можна злити з вкладками файлів. У першій будуть з'являтися всі створені змінні, константи та функції з їх значеннями. Друга призначена для пошуку документації для вбудованих або підключених пакетів чи функцій, працює навіть офлайн. Третя – місце для відображення графіків та малюнків, створених кодом.
      </p>
      <p>
        Для демонстрації різних варіянтів запуску коду, спочатку варто запустити Julia. Поставте курсор в REPL, натисніть клавішу "Ентер". Перший запуск може зайняти деякий час, адже деякі компоненти мають довстановитися. У цілому, є два методи запуску коду: в інтерактивному режимі та запуск коду з файлу. Для прикладу візьмемо код <code>println("Вітаємо в Julia")</code>, що друкує текст "Вітаємо в Julia". Альтернативно, можете спробувати рядок <code>cos(π/2)</code> або <code>cos(pi/2)</code>, який власне рахує косинус від π/2 (отримаєте дуже маленьке число близьке до нуля).
      </p>
      <p>
        Після того як ви побачите <code>julia></code> в REPL можете вставити код прямо туди й натиснути ентер. Під вашим рядком введення отрмаєте відповідь і керунок перенесеться знову на рядок вводу.
      </p>
      <code><pre>
        <b>julia></b> println("Вітаємо в Julia")
        Вітаємо в Julia

        <b>julia></b> cos(pi/2)
        6.123233995736766e-17</pre></code>
      <p>
        Для запуску коду з файлу, потрібно створити новий файл коду Джулії (Ctrl+N), такі файли зберігаються з розширеннями <code>.jl</code>. Після того як ви створили файл, можете вставити декілька рядків коду та зберегти його. Поставивши курсор на рядок з кодом і натиснувши Ctrl+Enter ви запустите цей рядок коремо й отримаэте результат або поруч, або в REPL. Аби запустити весь файл разом, натисніть Ctrl+Shift+Enter.
      </p>
      <h2 id="syntax">Базовий синтаксис</h2>
      <p>
        Перейдемо до синтаксису.
      </p>
      <div class="row">
        <div class="column">
          <code>
            x = 10 <span class="cmnt"># ціла числова змінна x, що дорівнює 10</span><br>
            a = "hello" <span class="cmnt"># текстова змінна а, що дорівнює "hello"</span><br>
            с = 'ї' <span class="cmnt"># символьна змінна c, що дорівнює символу 'ї' (одинарні лапки)</span><br>
            variable3 = 4.333 <span class="cmnt"># дробова змінна variable3, що дорівнює 4.333</span><br>
            complex1 = 1+2im <span class="cmnt"># комплексна числова змінна complex1, що дорівнює 1+2i</span><br>
            a = complex1 <span class="cmnt"># тепер змінна а дорівнює complex1, що дорівнює 1+2i</span><br>
          </code>
        </div>
        <div class="column">
          <p>
            Зверніть увагу, що будь-який текст на рядку після </code> # </code> або відділений на багатьох рядках так: <code>#= текст =#</code> абсолютно ігнорується і є коментарем.
          </p>
        </div>
      </div>
      <p>
        Основні арифметичні та алгебраїчні операції позначаються в цілому природнім чином: <code>+ - * / ^ % sqrt cos sin tan</code>
      </p>
      <p>
        Для задання функцій є два різних синтаксиси (насправді більше, однак зосередимося на цих виразах). Перший більш математичний, але не підходить для задання складних функцій.
      </p>
      <div class="row">
        <div class="column" style="flex:70%;padding-bottom: 15px;">
          <code>
            <span class="cmnt"># ====</span><br>
            f(x) = x^2 - 4x + 17 <span class="cmnt"># квадратична функція f(x)</span><br>
            G(x, y) = -y^2 - x*y + x^2 - 4x + 2 <span class="cmnt"># функція G(x, y) від двох змінних</span><br>
            <br>
            <span class="cmnt"># виклик функцій</span><br>
            f(1) <br>
            G(2, 3.5) + G(100, 1+2im)<br>
            <span class="cmnt"># ====</span><br>
          </code>
        </div>
        <div class="column" style="flex:30%;padding-bottom: 15px;">
          <p>
            Задання функцій в один рядок.
          </p>
        </div>
      </div>
      <div class="row">
        <div class="column" style="flex:70%;padding-bottom: 15px;">
          <code>
            <span class="cmnt"># ====</span><br>
            function f(x) <br>
            x^2 - 4x + 17 <br>
            end <br>
            <br>
            function G(x, y) <br>
            return -y^2 - x*y + x^2 - 4x + 2 <br>
            end <br>
            <br>
            <span class="cmnt"># виклик функцій</span><br>
            f(1) <br>
            G(2, 3.5) + G(100, 1+2im)<br>
            <span class="cmnt"># ====</span><br>
          </code>
        </div>
        <div class="column" style="flex:30%">
          <p>
            Кодове слово <code>return</code> для позначення значення, яке повертатиме функція опціональне в мові Julia. За замовчуванням, результат роботи останнього рядку повертається.
          </p>
        </div>
      </div>
      <div class="row">
        <div class="column" style="flex:70%">
          <code>
            <span class="cmnt"># ====</span><br>
            foo(x, y) = x + y <span class="cmnt"># перший метод foo</span><br>
            <br>
            <span class="cmnt"># другий метод foo</span><br>
            function foo(x::Number)<br>
            x^2 <br>
            end <br>
            <br>
            <span class="cmnt"># третій метод foo</span><br>
            function foo(str::String)<br>
            return str*" - заданий рядок" <br>
            end <br>
            <span class="cmnt"># ====</span><br>
          </code>
        </div>
        <div class="column" style="flex:30%">
          <p>
            Одна з потужних особливостей мови Julia це те, що можна задати одній функції декілька <b>методів</b>, а компілятор сам підбере необхідний при виклику функції.</p>
        </div>
      </div>
      <p>
        В останньому прикладі ліворуч перший варіянт <code>foo</code> спрацює при передачі <code>foo</code> будь-яких двох арґументів. Другий варіянт <code>foo</code> спрацює, якщо передати <code>foo</code> якесь одне число в якості арґумента (повернеться квадрат оцього числа). Третій - якщо передати текстовий рядок (повернеться той самий рядок із текстом " - заданий рядок" укінці).
      </p>
      <p>
        Тепер поглянемо на умовні блоки та цикли. Як можна бачити з блоку створення фукнцій <code>function ... end</code>, блоки коду (окремі фрагменти) мають закінчуватися на кодове слово <code>end</code>. Аналогічно й із блоками умов <code>if ... end</code>, <code>if ... else ... end</code>, <code>if ... elseif ... else ... end</code>:
      </p>
      <div class="row">
        <div class="column" style="flex:70%">
          <code>
            <span class="cmnt"># ====</span><br>
            if a == b <span class="cmnt"># якщо a рівне b</span><br>
            ...<br>
            elseif a == c <span class="cmnt"># інакше, при a рівне c</span><br>
            ...<br>
            else <span class="cmnt"># інакше</span><br>
            ...<br>
            end <br>
          </code>
        </div>
        <div class="column" style="flex:30%">
          <p>
            Підблоки <code>elseif</code> та <code>else</code> - опціональні, а блоків <code>elseif</code> може бути скільки потрібно підряд.
          </p>
        </div>
      </div>
      <p>
        Далі наведено приклади циклів - конструкцій, що повторюють блоки коду, допоки виконується певна умова.
      </p>
      <div class="row">
        <div class="column" style="flex:70%">
          <code>
            <span class="cmnt"># ====</span><br>
            while a < b <span class="cmnt"># поки a менше b</span><br>
            ...<br>
            a = ...<span class="cmnt"># потрібно змінювати a, аби цикл не був нескінченним</span><br>
            end <br>
          </code>
        </div>
        <div class="column" style="flex:30%">
          <p>
            Підблоки <code>elseif</code> та <code>else</code> - опціональні, а блоків <code>elseif</code> може бути скільки потрібно підряд.
          </p>
        </div>
      </div>
      <div class="row">
        <div class="column" style="flex:70%">
          <code>
            <span class="cmnt"># ====</span><br>
            for i in a:b <span class="cmnt"># повторити для всіх i з проміжку від a до b</span><br>
            ...<br>
            end <br>
          </code>
        </div>
        <div class="column" style="flex:30%">
          <p>
            Фактично <code>a:b</code> формує перелік чисел від a до b з кроком 1. Можна змінити крок на довільне k <code>a:k:b</code>. Альтернативно, можна замінити на довільний перелік (вектор, кортеж, множина тощо). Наприклад, вектор з трьох чисел <code>[5.3, -100, pi]</code>.
          </p>
        </div>
      </div>
      <h2 id="math">Математика й масиви</h2>
      <p>
        Тепер до синтаксичних та функціональних переваг мови. Вирази вищої математики тут виглядають природньо й математично (як скажімо й один зі способів задання функцій). Та спершу розберемося з векторами, матрицями й масивами загалом. Власне, в Julia існує таке поняття як <b>масив</b> - впорядкований за індексами набір даних. Технічно, масиви мають містити однотипні елементи, однак, якщо ви зробите масив з 0 елементів (порожній масив, тип елементів неможливо встановити) або декількох елементів несумісного типу, то компілятор підбере тип масиву автоматично як <code>Any</code> - будь-що. Взагалі, в Julia доволі розвинена система типізації даних, одна з найкращих серед сучасних мов, однак зараз не про неї. Нам лише потрібно знати, що для типізації масиву компілятор обирає "мінімальний" тип, який зможе описати всі елементи масиву.
      </p>
      <code><pre>
        <b>julia></b> arr = ["текст", 10.5] <span class="cmnt"># одновимірний масив (вектор) arr типу Any</span>
        2-element Vector{Any}:
        "текст"
        10.5

        <b>julia></b> arr = [0, 10] <span class="cmnt"># вектор цілочисельного типу</span>
        2-element Vector{Int64}:
        0
        10

        <b>julia></b> arr = [0.0, 10] <span class="cmnt"># вектор десятичного чисельного типу</span>
        2-element Vector{Float64}:
        0.0
        10.0

        <b>julia></b> arr = Float64[0, 10] <span class="cmnt"># явно вказуємо тип, аби отримати вектор з Float64, а не з Int</span>
        2-element Vector{Float64}:
        0.0
        10.0

        <b>julia></b> arr[1] <span class="cmnt"># беремо перший елемент з arr</span>
        0.0
      </pre></code>
      <p>
        <b>Вектор</b> у Julia - це одновимірний масив, тобто це масив, де в кожного елементу один індекс. <b>Матриця</b> - двовимірний масив.
      </p>
      <code><pre>
        <b>julia></b> A = [1. 2
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp; 1]
        2×2 Matrix{Float64}:
        1.0  2.0
        2.0  1.0

        <b>julia></b> A = [1. 2; 2 1] <span class="cmnt"># альтернативний спосіб</span>
        2×2 Matrix{Float64}:
        1.0  2.0
        2.0  1.0

        <b>julia></b> A[1, 1] <span class="cmnt"># беремо перший елемент з A</span>
        1.0
      </pre></code>
      <p>
        Julia має вбудоване множення векторів та матриць, ба більше, загалом багато вбудованих оперцій з лінійної алгебри:
      </p>
        <code><pre>
          <b>julia></b> A*arr <span class="cmnt"># множення на вектор arr</span>
          2-element Vector{Float64}:
          20.0
          10.0

          <b>julia></b> A*[1 0 0; 0 1 0] <span class="cmnt"># помножимо A на якусь іншу неквадратну матрицю</span><br>
          2×3 Matrix{Float64}:
          1.0  2.0  0.0
          2.0  1.0  0.0

          <b>julia></b> A' <span class="cmnt"># транспонуємо (але матриця симетрична)</span>
          2×2 adjoint(::Matrix{Float64}) with eltype Float64:
           1.0  2.0
           2.0  1.0

          <b>julia></b> A'A <span class="cmnt"># транспонуємо й помножимо на саму A</span>
          2×2 Matrix{Float64}:
           5.0  4.0
           4.0  5.0

          <b>julia></b> 2A <span class="cmnt"># або A*2 - помножимо на константу 2 </span>
          2×2 Matrix{Float64}:
           2.0  4.0
           4.0  2.0

          <b>julia></b> A^2 <span class="cmnt"># A у квадраті (сама на себе) </span>
          2×2 Matrix{Float64}:
           5.0  4.0
           4.0  5.0

          <b>julia></b> A^0.5 <span class="cmnt"># корінь квадратний з A (комплексна матриця)</span>
          2×2 LinearAlgebra.Symmetric{ComplexF64, Matrix{ComplexF64}}:
           0.866025+0.5im  0.866025-0.5im
           0.866025-0.5im  0.866025+0.5im
       </pre></code>
       <p>
         Як бачимо з останнього обчислення \(\sqrt{A}\) в Джулії передбачені навіть такі високоматематичні операції як взяття матричного кореня. Так само тут передбачені й взяття матричних синусу, косинусу, експоненти й так далі. До речі, можна помітити, що такі складні математичні операції займають певний час для виконання в середовищі. Це факт, однак 99% цього часу - компіляція функцій. Тобто створення самої функції як такої в машинному коді, до цього Джулія знає лише про сам факт існування таких методів. Після компіляції (що для Julia еквівалентно першому виклику функції) всі функції працюють миттєво (спробуйте повторити дію й результат отримаєте набагато швидше, навіть трохи змінивши вхідні дані). Більше про це нижче в <a href="#compspeed">"Компіляція та швидкість"</a>.
       </p>
       <code><pre>
         <b>julia></b> julia> sin(A)
          2×2 Matrix{Float64}:
           -0.350175   0.491295
            0.491295  -0.350175

          <b>julia></b> cos(A)
          2×2 Matrix{Float64}:
           -0.224845  -0.765147
           -0.765147  -0.224845

          <b>julia></b> exp(A)
          2×2 Matrix{Float64}:
           10.2267    9.85883
            9.85883  10.2267
      </pre></code>
      <p>
        А що як нам потрібно піднести до степеня чи порахувати якусь функцію не від усієї матриці, а від кожного її елемента, поелементно? Це робиться дуже просто за допомогою крапки. Аналогічно це працює, до речі, не тільки для матриць, а й для масивів будь-якого вигляду.
      </p>
      <code><pre>
        <b>julia></b> A.^2 <span class="cmnt"># всі елементи A у квадраті </span>
        2×2 Matrix{Float64}:
         1.0  4.0
         4.0  1.0

        <b>julia></b> sin.(A) <span class="cmnt"># синус від усіх елементів A</span>
        2×2 Matrix{Float64}:
         0.841471  0.909297
         0.909297  0.841471

        <b>julia></b> p(x) = x^2 - 2x + 1 <span class="cmnt"># задаємо довліьну функцію p(x)</span>
        p (generic function with 1 method)

        <b>julia></b> p.(A) <span class="cmnt"># запускаємо p(x) на всіх елементах A</span>
        2×2 Matrix{Float64}:
         0.0  1.0
         1.0  0.0

        <b>julia></b> A .+ 1 == A .+ [1 1; 1 1] <span class="cmnt"># поелементне додавання числа й поелементне додавання іншої матриці такого ж розміру (рівні в даному випадку)</span>
        true

        <b>julia></b> 2arr == arr .* 2 <span class="cmnt"># еквівалентні множення вектора на скаляр та поелементне множення масиву</span>
        true
      </pre></code>
       <p>
         Для інших речей з лінійної алгебри, на кшталт оператора ідентичности, розкладів матриць тощо, потрібно підключити відповідну бібліотеку.
       </p>
       <code><pre>
         <b>julia></b> using LinearAlgebra

         <b>julia></b> A*I
          2×2 Matrix{Float64}:
           1.0  2.0
           2.0  1.0

          <b>julia></b> svd(A) <span class="cmnt"># singular value decomposition (розклад матриці A)</span>
          SVD{Float64, Float64, Matrix{Float64}}
          U factor:
          2×2 Matrix{Float64}:
           -0.707107  -0.707107
           -0.707107   0.707107
          singular values:
          2-element Vector{Float64}:
           2.9999999999999996
           1.0
          Vt factor:
          2×2 Matrix{Float64}:
           -0.707107  -0.707107
            0.707107  -0.707107
      </pre></code>
      <h2 id="plots">Графіки та бібліотеки</h2>
      <p>
        Раз уже ми говоримо про якісь бібліотеки чи пакети (тобто додатки до самої Джулії), то варто показати, як встановлюються додаткові пакети. Зазвичай це робиться двома рядками коду в самому середовищі Джулії.
      </p>
      <code><pre>
        <b>julia></b> import Pkg; Pkg.add("ІМ'Я ПАКЕТУ")

        <b>julia></b> import Pkg; Pkg.add("Plots")<span class="cmnt"> # наприклад установимо Plots</span>
      </pre></code>
      <p>
        Надалі, після встановлення, можна просто писати в програмах <code>using Plots</code> та користуватися тим, що додає цей пакет. А конкретно, Plots дозволяє малювати графіки й діяграми. Наприклад, створіть файл з наступним кодом (раджу запускати його порядково, аби зрозуміти що відбувається з кожним кроком)
      </p>
      <code><pre>
        using Plots <span class="cmnt"># підключаємо Plots</span>

        xs = -4:0.1:4 <span class="cmnt"># робимо перелік чисел від -4 до 4 з кроком 0.1</span>
        cosx = cos.(xs) <span class="cmnt"># рахуємо від усіх чисел переліку xs косинус та зберігаємо в cosx</span>
        sinx = sin.(xs) <span class="cmnt"># рахуємо від усіх чисел переліку xs синус та зберігаємо в sinx</span>

        plot(xs, cosx, label="cos(x)") <span class="cmnt"># малюємо графік косинуса, на легенді діяграми пишемо "cos(x)"</span>
        plot!(xs, sinx, label="sin(x)") <span class="cmnt"># додаємо графік синуса на ту саму діяграму, на легенді діяграми пишемо "sin(x)"</span>
      </pre></code>
      <p>
        <code>plot</code> - функція, що приймає два одновимірних масиви однакового розміру, які задають набір точок графіку (ікси та ігреки, умовно). додатково можна передати ім'я функції для позначення. Для того аби додати графік на попередній, а не створювати абсолютно нову картинку, використовується <code>plot!</code> (у цілому, знаком оклику позначаються функції, що можуть змінювати значення зовні себе).
      </p>
      <p>
        Насправді, в бібліотеці Plots суть купа інших речей. З її допомогою можна відмалювати майже будь-що.
      </p>
      <h2 id="compspeed">Компіляція та швидкість</h2>
      <p>
        Джулія – JIT-компільована мова (Just In Time Compilation - вчасна компіляція). У поєднанні з її парадигмою <a href="https://uk.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4">множинної диспетчеризації або мультиметоду</a> (multiple dispatch, про це вже йшлося <a href="#syntax">в особливостях синтаксису задання функцій</a>) це призводить до цікавих особливостей та швидкісних переваг над, наприклад, Python. Як тільки ми захочемо використати певну функцію чи її метод (варіянт), компілятор скомпілює її, й подальші використання цієї функції такого вигляду будуть миттєвими. До того як ми захочемо використовувати таку функцію й уперше викличемо її, навіть якщо ми задали її в коді явно, скомпільованою (тобто переведеною в машинний код та готовою до швидкого використання програмно) вона не буде.
      </p>
      <p>
        Задавши функцію та не вказавши чітко тип значень, які вона приймає, наприклад так <code>f(x, y) = x * y</code>, а не так <code>f(x::Int64, y::Int64)::Int64 = x * y</code>, ми зможемо використовувати її автоматично й ефективно на будь-яких данних, адже компілятор буде компілювати для всіх типів даних новий сумісний варіянт <code>f</code> щойно нам знадобиться використати її певним чином. Швидкість від відсутности типізації ми не втрачаємо, а тільки здобуваємо універсальність. Тобто, викликавши <code>f(1, 2)</code> ми спричинемо компіляцію чогось типу <code>f(x::Int64, y::Int64)::Int64 = x * y</code> для цілих чисел, а наступні виклики, скажімо, <code>f(400, -19)</code> чи <code>f(0, 0)</code> будуть працювати швидко. Можемо викликати <code>f("hello", "world")</code>, спричинивши компіляцію альтернативи <code>f(x::String, y::String)::String = x * y</code>, яка буде склеювати два рядки в один (множення двох рядків у Джулії робить саме це).
      </p>
      <code><pre>
        <b>julia></b> f(x, y) = x * y <span class="cmnt"># задаємо загальну функцію</span>
        f (generic function with 1 method)

        <b>julia></b> f(1, 2) <span class="cmnt"># спричиняємо компіляцію варіянту f(x, y) для цілих чисел</span>
        2

        <b>julia></b> f(-1, 20) <span class="cmnt"># запускаться вже скомпільований варіянт</span>
        -20

        <b>julia></b> f("hello", "world") <span class="cmnt"># аналогічно спричиняємо компіляцію варіянту f(x, y) для рядків</span>
        "helloworld"

        <b>julia></b> f("a", "b")
        "ab"
      </pre></code>
      <p>
        Щоправда, тут наша функція занадто проста, щоб ми відчули час компіляції та пришвидшення коду. Тому пропоную спробувати ще раз із складнішою функцією: матричний синус.
      </p>
      <code><pre>
        <b>julia></b> A = [1. 0; 0 3]; B = [2. 7; -1 4]; <span class="cmnt"># задаємо якісь різні матриці одного типу</span>

        <b>julia></b> sin(A) <span class="cmnt"># відчутно довга компіляція доволі складного різновиду функції sin</span>
        2×2 Matrix{Float64}:
         0.841471  0.0
         0.0       0.14112

        <b>julia></b> sin(B) <span class="cmnt"># неймовірно швидкий запуск sin на іншій матриці схожого типу</span>
        2×2 Matrix{Float64}:
         3.1465   -16.262
         2.32315   -1.4998
      </pre></code>
      <p>
        Можна навіть подивитися на окремі скомпільовані методи функцій за допомогою спеціяльних макросів (вважайте що макроси – це просто спеціяльні слова мови Джулія, що починаються з <code>@</code>): <code>@code_native</code> – переглянути машинний код функції; <code>@code_llvm</code> – переглянути LLVM код функції (передує машинному в компіляції, тобто більш абстрактний та читабельний код); <code>@code_typed</code>, <code>@code_lowered</code> – іще більш високорівневий та читабельний формат коду. Детальніше англійською <a href="https://stackoverflow.com/questions/43453944/what-is-the-difference-between-code-native-code-typed-and-code-llvm-in-julia">тут</a>.
      </p>
      <code><pre>
      <b>julia></b> @code_native f(1,2) <span class="cmnt"># подивитися код скомпільований для цілих чисел</span>
      <b>julia></b> @code_native f("a", "b") <span class="cmnt"># подивитися код скомпільований для рядків</span>
      </pre></code>
      <p>
        <b>Важливо:</b> код, що не загорнутий у функції в Julia не компілюється! Це означає, що він виконуватиметься кожного разу за не дуже швидкий час, там не можна строго типізувати змінні, а важкий і повторюваний код буде суттєво вповільнувати програму. Тому все, що можна згрупувати до функцій; усе, що повторюється, варто загортати до функцій та викликати.
      </p>
      <p>
        До речі, ще один корисний макрос (так, нам тут доводиться розглядати декілька часткових випадків макросів, не кажучи про їх загалом) – <code>@inbounds</code>. Перед поясненням, що саме він робить варто пояснити ще дещо. У високорівневих мовах (як-от Python чи Julia) вирази індексації типу <code>a[i]</code> ховають під собою не просто взяття елементу за індексом, а ще й перевірку чи існує цей індекс у масиві взагалі. Це, звісно, корисно, щоб не натрапити на страшну помилку, однак така перевірка забирає відносно багато часу, особливо, коли таких "взяттів за індексом" у нас дуже багато. В мовах як С чи С++ такої перевірки немає. Julia всюди хоче наздоганяти С за швидкістю, саме тому для цього існує <code>@inbounds</code>, що вимикає такі перевірки. Використовувати його бажано тільки, коли точно знаємо, що наш індекс не "вилетить за межі масиву". Ставиться цей макрос перед циклом <code>for</code>, що пробігається по індексу:
      </p>
      <code><pre>
        @inbounds <b>for</b> i <b>in</b> 1:length(a) <span class="cmnt"># швидко пройдемо всі елементи масиву а </span>
          println(a[i])
        <b>end</b>
      </pre></code>
      <p>
        Щоправда, конкретний код вище багато сенсу, окрім демонстрації синтаксису не має, адже в даному випадку можна просто зробити наступний аналогічний цикл:
      </p>
      <code><pre>
        <b>for</b> el <b>in</b> a
          println(el)
        <b>end</b>
      </pre></code>
      <p>
        Можна багато чого сказати про ефективність коду Джулії, однак це виходить за межі оглядової статті. Якщо казати про загальні зауваження щодо ефективного коду, що не залежать від мови програмування, то раджу звернутися до <a href="cs.html#theory">теорії</a>, <a href="cs.html#tips">порад</a>, та й загалом статті про <a href="cs.html">комп'ютерні науки</a> англійською.
      </p>
    </div>

    <div style="text-align:center;padding-top:2%;"> <!-- license and credits -->
      <a href="https://atell.neocities.org">website by Atell Krasnopolski</a><br>
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.uk" target="_blank"><img alt="Creative Commons Licence" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png"></a>
    </div>
  </body>
</html>
